'''Задача 2
Для решений задач занятия №5 вынести общие части в модули. Сделать единую точку входа app.py.
Необходимо реализовать возможность старта выполнения кода одного из заданий сразу после запуска программы,
 а также после его выполнения предоставить возможность выполнить другое задание без повторного запуска программы.'''
#Легче всего когда все модули лежать в одной папке, но я испробовал подход,
#когда модули лежат в папках верхнего уровня, не в директории выполняемой программы
import sys
sys.path.insert(0, '/home/linux/GitHub/python130218_Bes')
from home_work_block4_Mike_B.matrix_module import matrix_with_input_col_and_row_numbers
print('Сперва сделаем матрицу для работы с ней далее:')
matrix = matrix_with_input_col_and_row_numbers()
'''
#Сделал, чтобы подгружало модуль матрицы в шапке программы и далее отрабатывало этот рандомный экземпляр
#Впорос - а как правильно делать структуру модулей для сторонних пользовотелей?
'''
task_N = 0
print('Данная программа выполняет пять задач из блока задач к занятию №5.\n'
      'Можно вводить только целые цифры от 0 до 4, соответствующие номеру задачи,\n'
      'либо цифру 5, если хотите остановить программу!')
while task_N != 5:
    test_input = 0
    task_N = input('Введите номер задания для выполнения, либо 5 для остановки: ')
    while test_input != 1:
        try:
            task_N = int(task_N)
            if task_N not in (0, 1, 2, 3, 4, 5):
                print('Введите только указанные в начале программы цифры!')
            test_input = 1
        except ValueError:
            print('Введите только указанные в начале программы цифры!')
            break
    # можно было и без try int сделать, просто заменить везде task_N на строковые и далее
    # if task_N not in ('0', '1', '2', '3', '4', '5') и т.д.
    if task_N == 0:
        from home_work_block4_Mike_B.HW_4_0 import do_HW_4_0
    elif task_N == 1:
        from home_work_block4_Mike_B.HW_4_1 import do_HW_4_1
        do_HW_4_1(matrix)
    elif task_N == 2:
        from home_work_block4_Mike_B.HW_4_2 import do_HW_4_2
        do_HW_4_2(matrix)
    elif task_N == 3:
        from home_work_block4_Mike_B.HW_4_3 import find_stud, list_students
        #exec('import home_work_block4_Mike_B.HW_4_3') # exec думал применять для совместимости модуля HW_4_3
        #  со следующими заданиями (HW_7_2), но придумал лучшее решение, тогда не надо коментить вызов функции в модуле
        find_stud(list_students)
    elif task_N == 4:
        from home_work_block4_Mike_B.HW_4_4 import do_HW_4_4
        do_HW_4_4(matrix)
    elif task_N == 5:
        print('Программа завершена, спасибо за внимамние и буду рад увидеть ваши пожелания.')
        break

'''На подумать:
Хорошая практика, если Вы импортируете модули в следующем порядке:

    стандартные библиотечные модули (например, sys, os, getopt, re)
    модули сторонних разработчиков (всё, что установлено в директории site-packages) -- например, PIL, NumPy и т.д.
    локально созданные модули

Иногда бывает необходимо поместить импорт в функцию или класс, чтобы избежать проблем с циклическим импортом. Gordon McMillan советует:
Циклический импорт отлично работает, если оба модуля используют форму import <module>. Но они терпят неудачу, 
когда второй модуль хочет извлечь имя из первого (from module import name) и импорт находится на внешнем уровне. 
Это происходит из-за того, что имена первого модуля ещё недоступны, так как первый модуль занят импортом второго.

В этом случае, если второй модуль используется только в одной функции, то импорт можно легко поместить в эту функцию. 
К тому времени, как он будет вызван, первый модуль уже закончит инициализацию и второй модуль осуществит свой импорт.

Может оказаться необходимым переместить импорт из начала файла, если один из модулей платформно-зависимый. 
В этом случае импорт всех модулей в начале файла окажется невозможным. 
В этой ситуации хорошим решением будет импорт нужных модулей в соответствующем платформно-зависимом коде.

Переносите импорт во вложенные области видимости, такие как определения функций, только если Вы столкнулись с проблемой, 
например циклического импорта, или если Вы пытаетесь сократить время инициализации модуля.

Эта техника полезна, если многие из импортов не являются необходимыми, и зависят от того, как программа будет исполняться. 
Вы также можете поместить импорт в функцию, если конкретные модули используются только в этой функции. 
Обратите внимание, что загрузить модуль в первый раз может оказаться дорого из-за задержки на инициализацию модуля, 
однако повторные загрузки "бесплатны", они стоят только пары поисков в словарях. 
Даже если имя модуля исчезло из области видимости, модуль скорее всего до сих пор находится в sys.modules.
'''
